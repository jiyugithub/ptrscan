.IX Title "PTRSCAN 1
.TH PTRSCAN 1 "Oct 2024" "ptrscan v1.0.2" "ptrscan"
.\" Automatically generated by Pandoc 3.1.11.1
.\"
.SS NAME
Pointer chain scanner (ptrscan)
.SS SYNOPSIS
\f[B]ptrscan\f[R] \f[B]\-a\f[R] [\f[I]ADDR\f[R]]
[\f[I]TARGET_PROCESS\f[R]]
.PD 0
.P
.PD
\f[B]ptrscan\f[R] \f[B]\-a\f[R] [\f[I]ADDR\f[R]] \f[B]\-A\f[R]
[\f[I]ALIGNMENT\f[R]] \f[B]\-o\f[R] [\f[I]OUTPUT_FILE\f[R]]
[\f[I]TARGET_PROCESS\f[R]]
.PD 0
.P
.PD
\f[B]ptrscan\f[R] \f[B]\-a\f[R] [\f[I]ADDR\f[R]] \f[B]\-r\f[R]
[\f[I]INPUT_FILE\f[R]] \f[B]\-x\f[R] \f[B]\-o\f[R]
[\f[I]OUTPUT_FILE\f[R]] [\f[I]TARGET_PROCESS\f[R]]
.SS DESCRIPTION
Given a target process and a target address, \f[B]ptrscan\f[R] will scan
all virtual memory areas with read & write permissions and locate
pointer chains leading to the target address.
The output produced by \f[B]ptrscan\f[R] can be used to locate and/or
navigate data structures of a target process.
.PP
\f[B]ptrscan\f[R] can save the discovered pointer chains to a
\f[I].pscan\f[R] file.
\f[B]pscan\f[R] can then verify the saved pointer chains against a
different instance of the target process to eliminate the vast majority
of false positives.
.PP
A pointer chain consists of a starting address, denoted by the basename
of a backing object, followed by a series of offsets.
To resolve backing object addresses, refer to the appropriate
\f[I]/proc//maps\f[R] entries.
.SS OPTIONS
\f[B]\-w\f[R] \f[I]OUTPUT_FILE\f[R],
\f[B]\[en]output\-file\f[R]=\f[I]OUTPUT_FILE\f[R]
.PD 0
.P
.PD
Save pointer chains to a file.
Works for both newly discovered, or verified pointer chains.
.PP
\f[B]\-r\f[R] \f[I]INPUT_FILE\f[R],
\f[B]\[en]input\-file\f[R]=\f[I]INPUT_FILE\f[R]
.PD 0
.P
.PD
Read pointer chains from a file.
Without the \f[B]\-x\f[R] option, this simply prints saved pointer
chains to \f[I]stdout\f[R].
.PP
\f[B]\-T\f[R], \f[B]\[en]ui\-term\f[R]
.PD 0
.P
.PD
[\f[I]default\f[R]] Use the terminal interface.
.PP
\f[B]\-N\f[R], \f[B]\[en]ui\-ncurses\f[R]
.PD 0
.P
.PD
[\f[B]not implemented\f[R]] Use the ncurses interface.
.PP
\f[B]\-p\f[R], \f[B]\[en]iface\-procfs\f[R]
.PD 0
.P
.PD
[\f[I]default\f[R]] Use the \f[I]procfs\f[R] interface from
\f[B]liblain\f[R].
This will use \f[I]/proc/[pid]/mem\f[R] and \f[I]/proc/[pid]/maps\f[R]
for accessing memory of the target.
For more information, see \f[B]man 3\f[R] \f[I]liblain_iface\f[R].
.PP
\f[B]\-k\f[R], \f[B]\[en]iface\-lainko\f[R]
.PD 0
.P
.PD
Use the \f[I]lain.ko\f[R] interface from \f[B]liblain\f[R].
This will use the \f[B]lain.ko\f[R] kernel driver for accessing memory
of the target.
To use this \f[B]liblain\f[R] interface, you will need to have
\f[B]lain.ko\f[R] already loaded into your kernel.
.PP
\f[B]\-c\f[R], \f[B]\[en]colour\f[R]
.PD 0
.P
.PD
Enable coloured output for printing results.
.PP
\f[B]\-n\f[R], \f[B]\[en]no\-colour\f[R]
.PD 0
.P
.PD
[\f[I]default\f[R]] Disable coloured output for printing results.
.PP
\f[B]\-v\f[R], \f[B]\[en]verbose\f[R]
.PD 0
.P
.PD
Report on progress for each thread at each depth level.
This floods the terminal.
.PP
\f[B]\-A\f[R] \f[I]ALIGNMENT\f[R],
\f[B]\[en]alignment\f[R]=\f[I]ALIGNMENT\f[R]
.PD 0
.P
.PD
Boundary to which pointers are aligned.
For example: If set to 4, \f[B]ptrscan\f[R] will only scan for pointers
at 0x4, 0x8, 0xc, [\&...].
.PP
\f[B]\-b\f[R] \f[I]BIT_WIDTH\f[R],
\f[B]\[en]byte\-width\f[R]=\f[I]BIT_WIDTH\f[R]
.PD 0
.P
.PD
Maximum number of bytes the target\[cq]s architecture can process
simultaneously.
For example: On x86 byte width is 4, on x86_64 byte idth is 8.
.PP
\f[B]\-a\f[R] \f[I]ADDRESS\f[R],
\f[B]\[en]target\-address\f[R]=\f[I]ADDRESS\f[R]
.PD 0
.P
.PD
Address to pointer scan for.
.PP
\f[B]\-s\f[R] \f[I]SIZE\f[R],
\f[B]\[en]max\-struct\-size\f[R]=\f[I]SIZE\f[R]
.PD 0
.P
.PD
The maximum size structure to accept when performing the scan.
For example: If your target address is 0x800, and \f[B]ptrscan\f[R]
finds a pointer to 0x600, \f[I]SIZE\f[R] will need to be at least 0x200
for this pointer to be added to the chain.
.PP
\f[B]\-d\f[R] \f[I]DEPTH\f[R], \f[B]\[en]max\-depth\f[R]=\f[I]DEPTH\f[R]
.PD 0
.P
.PD
The maximum depth for this scan.
.PP
\f[B]\-t\f[R] \f[I]THREADS\f[R],
\f[B]\[en]threads\f[R]=\f[I]THREADS\f[R]
.PD 0
.P
.PD
Number of threads to use for the scan.
.PP
\f[B]\-S\f[R] \f[I]FMT\f[R],
\f[B]\[en]extra\-static\-regions\f[R]=\f[I]FMT\f[R]
.PD 0
.P
.PD
In addition to \f[I][stack]\f[R] and .bss, treat backing objects
included in \f[I]FMT\f[R] also as static.
The format for \f[I]FMT\f[R] is:
.IP
.EX
<basename 1>,0:<basename 2>,0:<basename n>,0  
.EE
.PP
Where <basename x> is the base name of the backing object to treat as
static.
.PP
\f[B]\-R\f[R] \f[I]FMT\f[R],
\f[B]\[en]exclusive\-rw\-regions\f[R]=\f[I]FMT\f[R]
.PD 0
.P
.PD
Instead of scanning every memory area with read & write permissions,
scan only the areas listed in \f[I]FMT\f[R].
The format for \f[I]FMT\f[R] is:
.IP
.EX
<basename 1>,0:<basename 2>,0:<basename n>,0  
.EE
.PP
Where <basename x> is the base name of the backing object to exclusively
scan.
Note that \f[I][stack]\f[R], \f[I][heap]\f[R], and .bss are always
scanned.
.PP
\f[B]\-O\f[R] \f[I]PRESETS\f[R],
\f[B]\[en]preset\-offsets\f[R]=\f[I]PRESETS\f[R]
.PD 0
.P
.PD
Define the first preset offsets from the target address.
The format for \f[I]PRESETS\f[R] is:
.IP
.EX
<offset 1>,<offset 2>,<offset n>
.EE
.PP
Where <offset x> is an offset supplied either in decimal or hexadecimal
form (`0x' prefix required).
.PP
Preset offsets are specified in reverse order.
For example: Preset offsets of 0x20,0x10,0x80 will result in a chain
[\&...]
0x80 0x10 0x20.
.PP
\f[B]\-x\f[R], \f[B]\[en]verify\f[R]
.PD 0
.P
.PD
Verify the pointer chains read with \f[B]\-r\f[R].
This option will cause \f[B]ptrscan\f[R] to follow each chain in the
input file and verify that it arrives at the correct address, specified
with \f[B]\-a\f[R].
.SS EXAMPLES
The following two examples follow the most common use case.
Note that the addresses used in these examples are not realistic.
.PP
\f[B]ptrscan\f[R] \f[B]\-a\f[R] \f[I]0x1000\f[R] \f[B]\-b\f[R]
\f[I]8\f[R] \f[B]\-A\f[R] \f[I]2\f[R] \f[B]\-s\f[R] 0x200 \f[B]\-d\f[R]
\f[I]4\f[R] \f[B]\-t\f[R] \f[I]6\f[R] \f[B]\-w\f[R]
\f[I]first.pscan\f[R] \f[I]1337\f[R]
.PP
Pointer scan for address \f[I]0x1000\f[R] (\f[B]\-a\f[R]).
Set architecture\[cq]s byte width to \f[I]8\f[R] (\f[B]\-b\f[R]).
Set pointer alignment in the target to \f[I]2\f[R] (\f[B]\-A\f[R]).
Accept structure sizes up to \f[I]0x200\f[R] bytes (\f[B]\-s\f[R]).
Scan up to the depth of \f[I]4\f[R] levels (\f[B]\-d\f[R]).
Use \f[I]6\f[R] threads for the scan (\f[B]\-t\f[R]).
Save the discovered pointer chains to \f[I]first.pscan\f[R]
(\f[B]\-w\f[R]).
The target process has a PID of \f[I]1337\f[R].
.PP
\f[B]ptrscan\f[R] \f[B]\-a\f[R] \f[I]0x2000\f[R] \f[B]\-r\f[R]
\f[I]first.pscan\f[R] \f[B]\-x\f[R] \f[B]\-w\f[R]
\f[I]verified.pscan\f[R] \f[I]target\f[R].
.PP
Set the target address to \f[I]0x2000\f[R] (\f[B]\-a\f[R]).
Read a previous pointer scan from \f[I]first.pscan\f[R] (\f[B]\-r\f[R]).
Verify this scan (\f[B]\-x\f[R]).
Save the verified pointer chains to \f[I]verified.pscan\f[R]
(\f[B]\-w\f[R]).
The target process is called \f[I]target\f[R] (\f[B]ptrscan\f[R] can
resolve the PID for you).
.SS AUTHOR
Written by vykt.
.SS SEE ALSO
\f[B]ptrwatch\f[R] can be used to watch pointerchains found with
\f[B]ptrscan\f[R] in real time.
.PP
You can use \f[B]liblain\f[R] to write tools that make use of pointer
chains found with \f[B]ptrscan\f[R].
For bypassing countermeasures with \f[B]liblain\f[R], see
\f[B]lain.ko\f[R].
